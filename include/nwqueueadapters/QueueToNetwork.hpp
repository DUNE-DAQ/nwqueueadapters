/**
 * @file QueueToNetwork.hpp
 *
 * Based on VectorIntIPMSenderDAQModule from IPM
 *
 * This is part of the DUNE DAQ Application Framework, copyright 2020.
 * Licensing/copyright details are in the COPYING file that you should have
 * received with this code.
 */

#ifndef NWQUEUEADAPTERS_INCLUDE_NWQUEUEADAPTERS_QUEUETONETWORK_HPP_
#define NWQUEUEADAPTERS_INCLUDE_NWQUEUEADAPTERS_QUEUETONETWORK_HPP_

#include "appfwk/DAQModule.hpp"
#include "appfwk/DAQSource.hpp"
#include "appfwk/ThreadHelper.hpp"
#include "appfwk/cmd/Nljs.hpp"
#include "nwqueueadapters/Issues.hpp"
#include "nwqueueadapters/NetworkObjectSender.hpp"
#include "nwqueueadapters/queuetonetworkinfo/InfoNljs.hpp"
#include "serialization/Serialization.hpp"


#include <chrono>
#include <ers/Issue.hpp>

#include <cetlib/BasicPluginFactory.h>
#include <cetlib/compiler_macros.h>

#include <ipm/Sender.hpp>
#include <memory>
#include <string>
#include <vector>

#ifndef EXTERN_C_FUNC_DECLARE_START
// NOLINTNEXTLINE(build/define_used)
#define EXTERN_C_FUNC_DECLARE_START                                                                                    \
  extern "C"                                                                                                           \
  {
#endif

// NOLINTNEXTLINE(build/define_used)
#define MAKEQNIMPL(r, data, klass)                                                                                     \
  if (plugin_name == BOOST_PP_STRINGIZE(klass))                                                                        \
    return std::make_unique<dunedaq::nwqueueadapters::QueueToNetworkImpl<klass>>(queue_instance, sender_conf); // NOLINT
/**
 * @brief Declare the function that will be called by the plugin loader
 * @param klass Class for which a QueueToNetwork module will be used
 */
// NOLINTNEXTLINE(build/define_used)
#define DEFINE_DUNE_QUEUE_TO_NETWORK(...)                                                                              \
  EXTERN_C_FUNC_DECLARE_START                                                                                          \
  std::unique_ptr<dunedaq::nwqueueadapters::QueueToNetworkBase> makeQToN(                                              \
    std::string const& plugin_name,                                                                                    \
    const std::string queue_instance,                                                                                  \
    const dunedaq::nwqueueadapters::networkobjectsender::Conf& sender_conf)                                            \
  {                                                                                                                    \
    BOOST_PP_SEQ_FOR_EACH(MAKEQNIMPL, , BOOST_PP_VARIADIC_TO_SEQ(__VA_ARGS__))                                         \
    return nullptr;                                                                                                    \
  }                                                                                                                    \
  }

namespace dunedaq::nwqueueadapters {

/**
 * @brief Base class for the queue-to-network implementation
 *
 * This class exists to perform a sort of "type erasure" for @c
 * QueueToNetwork: that class would more naturally
 * take a template parameter for the type of the queue it's reading
 * from (ie, @c QueueToNetwork<T>), but the plugin
 * factory we're using for instantiating @c DAQModules doesn't
 * support classes specialized on a template parameter. So instead,
 * @c QueueToNetwork holds an instance of @c
 * QueueToNetworkBase, and we push the "templateness" down to @c
 * QueueToNetworkImpl, which derives from @c QueueToNetworkBase.
 *
 * With this done, we still need to actually instantiate a
 * QueueToNetworkImpl<T> for the right value of T at runtime, and
 * that's done by codegen with moo (see
 * schema/nwqueueadapters-qtonmaker.hpp.j2) to produce a function that
 * will return an instance of the appropriate specialization of
 * QueueToNetworkImpl<T>, provided that T is one of the classes
 * generated by schema.
 */
class QueueToNetworkBase
{
public:
  QueueToNetworkBase() = default;
  virtual ~QueueToNetworkBase() = default;

  QueueToNetworkBase(QueueToNetworkBase const&) = delete;
  QueueToNetworkBase(QueueToNetworkBase&&) = default;
  QueueToNetworkBase& operator=(QueueToNetworkBase const&) = delete;
  QueueToNetworkBase& operator=(QueueToNetworkBase&&) = default;

  virtual void get() = 0;
};

/**
 * @brief Implementation of QueueToNetworkBase that holds the "templateness"
 *
 * See documentation for QueueToNetworkBase for a (slightly) more complete description
 *
 */
template<typename MsgType>
class QueueToNetworkImpl : public QueueToNetworkBase
{
public:
  QueueToNetworkImpl(const std::string queue_instance,
                     const dunedaq::nwqueueadapters::networkobjectsender::Conf& sender_conf)
    : m_sender(sender_conf)
  {
    m_input_queue.reset(new appfwk::DAQSource<MsgType>(queue_instance));

    // Send a single control message that the other end will ignore,
    // to ensure that the connection is made before this function
    // finishes.
    //
    // This is to avoid data loss in the following case. Suppose we have:
    //
    //   ModuleA --q1--> Q2N (ipm::Sender) ==network==> N2Q --q2--> ModuleB
    //
    // And both:
    //
    // * ModuleA is sent "conf" before ModuleB
    // * ModuleA pushes to q1 during its do_configure() function
    //
    // Then Q2N will pop the item off its queue and attempt to send
    // the item _before_ ModuleB connects. The connection is not yet
    // made, and so the network send() times out and the item is
    // dropped. Q2N has no way to tell ModuleA that the item has been
    // dropped, so we get silent data loss
    //
    // So instead, we send a single "control" message before we start
    // popping items from the input queue. If this message times out,
    // we throw an exception and so never get to the point where we're
    // popping items from the input queue. This is kind of ugly, but
    // it's better than silently dropping data.
    //
    // (The receiving end has logic to deal with control messages,
    // which currently just ignores them. There's nothing it could
    // usefully do with this message anyway)
    //
    // (If the Q2N is an ipm::Publisher instead of ipm::Sender,
    // messages sent before the connection is made are silently
    // dropped by ZeroMQ. This is intended, since subscribers (or lack
    // of them) should have no effect on the sender. If you don't want
    // message loss, you have to use something other than Publisher.)
    
    try{
      m_sender.send_control_message('\0', std::chrono::milliseconds(sender_conf.control_timeout));
    } catch (ipm::SendTimeoutExpired& e) {
      throw ReceiverNotReady(ERS_HERE, queue_instance, sender_conf.address, e);
    }
  }

  /**
   * @brief Pop an item off the queue and send it off to the network
   */
  virtual void get()
  {
    MsgType msg;
    m_input_queue->pop(msg, std::chrono::milliseconds(10));
    m_sender.send(msg, std::chrono::milliseconds(10));
  }

private:
  std::unique_ptr<appfwk::DAQSource<MsgType>> m_input_queue;
  dunedaq::nwqueueadapters::NetworkObjectSender<MsgType> m_sender;
};

/**
 * @brief QueueToNetwork connects a queue to an IPM sender, transparently to users of the queue
 *
 * This class is limited to types that are generated by schema in this
 * package. For reasons of plugin implementation, the type of objects
 * passed on the input queue is not specified as a template parameter,
 * but as the configuration parameter @c msg_type, which must be
 * specified in the init command of the module
 */
class QueueToNetwork : public appfwk::DAQModule
{
public:
  /**
   * @brief QueueToNetwork Constructor
   * @param name Instance name for this QueueToNetwork instance
   */
  explicit QueueToNetwork(const std::string& name);

  QueueToNetwork(const QueueToNetwork&) = delete;            ///< QueueToNetwork is not copy-constructible
  QueueToNetwork& operator=(const QueueToNetwork&) = delete; ///< QueueToNetwork is not copy-assignable
  QueueToNetwork(QueueToNetwork&&) = delete;                 ///< QueueToNetwork is not move-constructible
  QueueToNetwork& operator=(QueueToNetwork&&) = delete;      ///< QueueToNetwork is not move-assignable

  void init(const data_t&) override;

  void get_info(opmonlib::InfoCollector& ci, int level) override;
  
private:
  // Commands
  void do_configure(const data_t&);
  void do_scrap(const data_t&);

  // Threading
  void do_work(std::atomic<bool>& running_flag);
  appfwk::ThreadHelper m_thread;

  std::string m_queue_instance;
  std::string m_message_type_name;
  std::unique_ptr<QueueToNetworkBase> m_impl;

  queuetonetworkinfo::Info m_opmon_info;
  std::mutex m_opmon_mutex;
};


std::unique_ptr<QueueToNetworkBase>
makeQueueToNetworkBase(std::string const& module_name,
                       std::string const& plugin_name,
                       const std::string queue_instance,
                       const dunedaq::nwqueueadapters::networkobjectsender::Conf& sender_conf)
{
  static cet::BasicPluginFactory bpf("duneNetworkQueue", "makeQToN");
  auto ptr = bpf.makePlugin<std::unique_ptr<QueueToNetworkBase>>(module_name, plugin_name, queue_instance, sender_conf);
  if (!ptr) {
    throw NoQueueToNetworkImpl(ERS_HERE, plugin_name, module_name, queue_instance);
  }
  return ptr;
}

} // namespace dunedaq::nwqueueadapters

#endif // NWQUEUEADAPTERS_INCLUDE_NWQUEUEADAPTERS_QUEUETONETWORK_HPP_
