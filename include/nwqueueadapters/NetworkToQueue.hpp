/**
 * @file VectorIntIPMReceiverDAQModule.hpp
 *
 * VectorIntIPMReceiverDAQModule receives vectors of integers from VectorIntIPMSenderDAQModule
 *
 * This is part of the DUNE DAQ Application Framework, copyright 2020.
 * Licensing/copyright details are in the COPYING file that you should have
 * received with this code.
 */

#ifndef NWQUEUEADAPTERS_INCLUDE_NWQUEUEADAPTERS_NETWORKTOQUEUE_HPP_
#define NWQUEUEADAPTERS_INCLUDE_NWQUEUEADAPTERS_NETWORKTOQUEUE_HPP_

#include "appfwk/DAQModule.hpp"
#include "appfwk/DAQSink.hpp"
#include "appfwk/ThreadHelper.hpp"
#include "appfwk/cmd/Nljs.hpp"
#include "nwqueueadapters/Issues.hpp"
#include "nwqueueadapters/NetworkObjectReceiver.hpp"
#include "nwqueueadapters/networktoqueueinfo/InfoNljs.hpp"
#include "serialization/Serialization.hpp"

#include "boost/preprocessor.hpp"
#include <cetlib/BasicPluginFactory.h>
#include <cetlib/compiler_macros.h>

#include <memory>
#include <string>
#include <variant>
#include <vector>

#ifndef EXTERN_C_FUNC_DECLARE_START
// NOLINTNEXTLINE(build/define_used)
#define EXTERN_C_FUNC_DECLARE_START                                                                                    \
  extern "C"                                                                                                           \
  {
#endif

// clang-format off
// NOLINTNEXTLINE(build/define_used)
#define MAKENQIMPL(r, data, klass)                                                                                     \
  if (plugin_name == BOOST_PP_STRINGIZE(klass))                                                                        \
    return std::make_unique<dunedaq::nwqueueadapters::NetworkToQueueImpl<klass>>(queue_instance, receiver_conf); // NOLINT
// clang-format on

/**
 * @brief Declare the function that will be called by the plugin loader
 * @param klass Class for which a NetworkToQueue module will be used
 */
// NOLINTNEXTLINE(build/define_used)
#define DEFINE_DUNE_NETWORK_TO_QUEUE(...)                                                                              \
  EXTERN_C_FUNC_DECLARE_START                                                                                          \
  std::unique_ptr<dunedaq::nwqueueadapters::NetworkToQueueBase> makeNToQ(                                              \
    std::string const& plugin_name,                                                                                    \
    const std::string queue_instance,                                                                                  \
    const dunedaq::nwqueueadapters::networkobjectreceiver::Conf& receiver_conf)                                        \
  {                                                                                                                    \
    BOOST_PP_SEQ_FOR_EACH(MAKENQIMPL, , BOOST_PP_VARIADIC_TO_SEQ(__VA_ARGS__))                                         \
    return nullptr;                                                                                                    \
  }                                                                                                                    \
  }

namespace dunedaq::nwqueueadapters {

class NetworkToQueueBase
{
public:
  NetworkToQueueBase() = default;
  virtual ~NetworkToQueueBase() = default;

  NetworkToQueueBase(NetworkToQueueBase const&) = delete;
  NetworkToQueueBase(NetworkToQueueBase&&) = default;
  NetworkToQueueBase& operator=(NetworkToQueueBase const&) = delete;
  NetworkToQueueBase& operator=(NetworkToQueueBase&&) = default;

  virtual void push() = 0;
};

template<typename T>
class NetworkToQueueImpl : public NetworkToQueueBase
{
public:
  NetworkToQueueImpl(const std::string queue_instance,
                     const dunedaq::nwqueueadapters::networkobjectreceiver::Conf& receiver_conf)
    : m_receiver(receiver_conf)
  {
    m_output_queue.reset(new appfwk::DAQSink<T>(queue_instance));
  }

  virtual void push()
  {
    std::variant<char, T> incoming=m_receiver.recv(std::chrono::milliseconds(10));
    if (std::holds_alternative<char>(incoming)) {
      // So far the only control message is the "test connection" message, which we ignore
    }
    else if (std::holds_alternative<T>(incoming)) {
      m_output_queue->push(std::move(std::get<T>(incoming)), std::chrono::milliseconds(10));
    }
  }

private:
  std::unique_ptr<appfwk::DAQSink<T>> m_output_queue;
  dunedaq::nwqueueadapters::NetworkObjectReceiver<T> m_receiver;
};

/**
 * @brief NetworkToQueue connects an incoming IPM
 * receiver to an app framework queue, transparently to users of the
 * queue
 *
 * This class is limited to types that are generated by schema in this
 * package. For reasons of plugin implementation, the type of objects
 * passed on the input queue is not specified as a template parameter,
 * but as the configuration parameter @c msg_type, which must be
 * specified in the init command of the module
 */
class NetworkToQueue : public appfwk::DAQModule
{
public:
  /**
   * @brief NetworkToQueue Constructor
   * @param name Instance name for this NetworkToQueue instance
   */
  explicit NetworkToQueue(const std::string& name);

  NetworkToQueue(const NetworkToQueue&) = delete;            ///< NetworkToQueue is not copy-constructible
  NetworkToQueue& operator=(const NetworkToQueue&) = delete; ///< NetworkToQueue is not copy-assignable
  NetworkToQueue(NetworkToQueue&&) = delete;                 ///< NetworkToQueue is not move-constructible
  NetworkToQueue& operator=(NetworkToQueue&&) = delete;      ///< NetworkToQueue is not move-assignable

  void init(const data_t&) override;

  void get_info(opmonlib::InfoCollector& ci, int level) override;
  
private:
  // Commands
  void do_configure(const data_t&);
  void do_scrap(const data_t&);

  // Threading
  appfwk::ThreadHelper m_thread;
  void do_work(std::atomic<bool>& running_flag);

  std::string m_queue_instance;
  std::string m_message_type_name;
  bool m_is_subscriber_type;
  std::unique_ptr<NetworkToQueueBase> m_impl;

  networktoqueueinfo::Info m_opmon_info;
  std::mutex m_opmon_mutex;
};

std::unique_ptr<NetworkToQueueBase>
makeNetworkToQueueBase(std::string const& module_name,
                       std::string const& plugin_name,
                       const std::string queue_instance,
                       const dunedaq::nwqueueadapters::networkobjectreceiver::Conf& sender_conf)
{
  static cet::BasicPluginFactory bpf("duneNetworkQueue", "makeNToQ");
  auto ptr = bpf.makePlugin<std::unique_ptr<NetworkToQueueBase>>(module_name, plugin_name, queue_instance, sender_conf);
  if (!ptr) {
    throw NoNetworkToQueueImpl(ERS_HERE, plugin_name, module_name, queue_instance);
  }
  return ptr;
}

} // namespace dunedaq::nwqueueadapters

#endif // NWQUEUEADAPTERS_INCLUDE_NWQUEUEADAPTERS_NETWORKTOQUEUE_HPP_
